{"name":"Docker Exec","tagline":"Execute code in many languages with Docker!","body":"### What?\r\nDocker Exec is a collection of Docker images capable of executing code in many different programming languages without requiring a single compiler or script interpreter on your machine.\r\n\r\nThe ```dexec``` command line interface provides a simple front end, picking the appropriate Docker image based on the source extension.\r\n\r\n**See the [dexec installation guide](https://github.com/docker-exec/dexec/blob/master/README.md#installation) to get started**\r\n\r\n![dexec demo animation](https://docker-exec.github.io/images/dexec-short-1.0.1.gif)\r\n\r\nLet's take a closer look at one of the examples, [helloworld.cpp](https://github.com/docker-exec/cpp/blob/v1.0.2/test/helloworld.cpp):\r\n\r\n```c++\r\n#include <iostream>\r\nint main() {\r\n    std::cout << \"Hello, World!\" << std::endl;\r\n    return 0;\r\n}\r\n```\r\n\r\nexecuting it is simple:\r\n\r\n```\r\n$ dexec foo.cpp\r\n\r\nHello, World!\r\n```\r\n\r\nDocker Exec also supports passing arguments to the executing program, passing arguments to the compiler, mounting extra files and directories in the executing container as well as the ability to make source files executable as scripts using a shebang.\r\n\r\n### Why?\r\nDocker Exec allows you to run code in a compiled language just as easily as you can for interpreted languages. This is useful for speeding up your ability to try things out in compiled languages.\r\n\r\nThe [uniform interface](https://github.com/docker-exec/dexec/blob/master/README.md#reference) used to execute source for all of the different languages means that calls to  ```dexec``` can be shelled out from other programs who need to execute arbitrary source, for example automated answer checkers for code tests in pre-interview situations or for university exercises.\r\n\r\nAnother benefit is that the only dependency on your machine becomes Docker instead of lots of different compilers and interpreters. Docker is a powerful tool and a lot is said about its potential for running web services and databases. However, it's also great for single program execution too and this is an example of how tools can be usefully virtualised just as well as web services.\r\n\r\nFurther to this, the virtualisation of the compilation and execution acts as a sandbox in the event you're not entirely sure how safe a piece of code is to run.\r\n\r\n### How?\r\nA Docker image exists for each target language, with an associated automated build job on Docker Hub. The image contains the compiler, runtime or interpreter for that language and a [bash script](https://github.com/docker-exec/image-common) that does any of the following depending on the language:\r\n\r\n* Compile the code and run the compiled executable.\r\n* Compile the code and use a runtime to execute the compiled bytecode.\r\n* Pass the code to a script interpreter.\r\n\r\nThe ```dexec``` utility wraps the following command:\r\n\r\n```sh\r\n$ docker run -t --rm \\\r\n    -v $(pwd -P)/foo.cpp:/tmp/dexec/build/foo.cpp \\\r\n    dexec/lang-cpp foo.cpp\r\n```\r\n\r\nArguments can be passed to the executing code using:\r\n\r\n```\r\n-a bar\r\n--arg bar\r\n--arg=bar\r\n```\r\n\r\nArguments can be passed to the compiler (if the language has one) using:\r\n\r\n```\r\n-b foo\r\n--build-arg foo\r\n--build-arg=foo\r\n```\r\n\r\nExtra file and folders can be mounted in the container with ```dexec``` using:\r\n\r\n```\r\n-i foo.hpp\r\n--include foo.hpp\r\n--include=foo.hpp\r\n```\r\n\r\nPrefixing a source file with a shebang that invokes dexec will make it executable:\r\n\r\n```\r\n#!/usr/bin/env dexec\r\n```\r\n\r\n### Where?\r\n* [dexec on GitHub](https://github.com/docker-exec/dexec)\r\n* [dexec on Bintray](https://bintray.com/dexec/release/dexec/view)\r\n* [Docker Exec GitHub Repositories](https://github.com/docker-exec)\r\n* [Docker Exec Images on Docker Hub](https://hub.docker.com/repos/dexec/)\r\n\r\n### Which?\r\nThe following languages are available:\r\n* [Bash](https://github.com/docker-exec/bash)\r\n* [C](https://github.com/docker-exec/c)\r\n* [Clojure](https://github.com/docker-exec/clojure)\r\n* [CoffeeScript](https://github.com/docker-exec/coffee)\r\n* [C++](https://github.com/docker-exec/cpp)\r\n* [C#](https://github.com/docker-exec/csharp)\r\n* [D](https://github.com/docker-exec/d)\r\n* [Erlang](https://github.com/docker-exec/erlang)\r\n* [F#](https://github.com/docker-exec/fsharp)\r\n* [Go](https://github.com/docker-exec/go)\r\n* [Groovy](https://github.com/docker-exec/groovy)\r\n* [Haskell](https://github.com/docker-exec/haskell)\r\n* [Java](https://github.com/docker-exec/java)\r\n* [Lisp](https://github.com/docker-exec/lisp)\r\n* [Lua](https://github.com/docker-exec/lua)\r\n* [Nim](https://github.com/docker-exec/nim)\r\n* [Node JS](https://github.com/docker-exec/node)\r\n* [Objective C](https://github.com/docker-exec/objc)\r\n* [OCaml](https://github.com/docker-exec/ocaml)\r\n* [Perl](https://github.com/docker-exec/perl)\r\n* [PHP](https://github.com/docker-exec/php)\r\n* [Python](https://github.com/docker-exec/python)\r\n* [R](https://github.com/docker-exec/r)\r\n* [Racket](https://github.com/docker-exec/racket)\r\n* [Ruby](https://github.com/docker-exec/ruby)\r\n* [Rust](https://github.com/docker-exec/rust)\r\n* [Scala](https://github.com/docker-exec/scala)\r\n\r\n### Who?\r\nI'm Andy Stanton ([@andystanton](https://github.com/andystanton)).\r\n\r\n### Help!\r\nDocumentation can be found and issues raised in each image's repository.","google":"UA-48544248-4","note":"Don't delete this file! It's used internally to help with page regeneration."}